Go
Building resilient services in Go
09 Sep 2016
Tags: go, golang, resilience, services, REST, microservices, someotherbuzzword

Tiago Katcipis
Neoway Business Solution
tiago.katcipis@neoway.com.br
http://github.com/NeowayLabs/presentations


* Agenda

- Resilience
- Timeouts
- Context
- Simple timeouts with contexts
- Calling expensive long running job
- Context best practices
- Making HTTP requests
- Serving HTTP requests
- Final thoughts


* Resilience

- Broad subject
- Encompasses dev + testing + ops
- Will focus on dev + testing


* Be cynical


It is not a matter of *if it will fail* but *what will happen when it fails*.

- Will your entire system freeze ?
- Start to answer with errors to never recover again until restarted manually ?
- Attend all clients equally poorly ?


* Things that can go wrong

- Downstream dependency not answering
- Downstream dependency giving errors
- Connections gets dropped
- Connection fails to handshake
- Connection takes 10 minutes to handshake
- An answer of a request is received with a speed of 1 byte per minute
- The request body is received with a speed of 1 byte per minute
- No more disk available
- No more file descriptors available
- No more memory available
- Sun flares flips bits from the memory :-)


* How far ?

- It can get as resilient as it can get
- Pretty much like security :-)
- Choose something to start with


* Microservices

.image ./img/integration-points.jpg _ 700


* Microservices

- Local call != Remote call
- Having lots of small services = lots of small integration points
- Networks have really fun ways to fail



* Timeouts

- Integration points must have timeouts
- Expensive and long running ops must have timeouts
- Seems simple, but it is easy to don't do it
- Go makes it even simpler :-)


* context.Context

- Moved to Go core in 1.7
- Models timeouts/deadlines and cancellation


* context.Context

.play examples/context.go


* Timeout Context

- Will be canceled when timeout expires
- Or when cancel is called


* Waiting to expire

.play examples/expiration.go


* cancel

- Always call it
- Guarantee resources are freed ASAP


* Canceling explicitly

.play examples/cancellation.go


* Context hierarchy: Child exits first

.play examples/hierarchy.go


* Context hierarchy: Parent exits first

.play examples/hierarchy2.go


* Context hierarchy: Parent cancelled

.play examples/hierarchy3.go


* Calling expensive operation

.play examples/expensive.go


* Timeout Overview

- Waiting for timeout is as simple as reading a channel
- It leverages Go closed channel behaviour
- Multiple goroutines can be waiting for a single done
- Contexts are hierarchical
- Cancelling parent cancels all children


* Context best practices

- Callee where context are inject can't cancel the operation
- Propagate context as the first parameter of functions
- Avoid using the values thing, basically a map[interface{}]interface{}


* HTTP timeouts

Talk about: https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/


* Further reading

- https://blog.golang.org/context
- https://peter.bourgon.org/blog/2016/07/11/context.html
- https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts
