Go
Less is a lot lot more
27 Apr 2015
Tags: go, golang

var Natel, Katcipis Tiago
Neoway Business Solution
tiago.natel@neoway.com.br / tiago.katcipis@neoway.com.br
http://github.com/NeowayLabs/presentations
@golang ON Slack


* Agenda

- Why another language ?
- How Go improves on other languages ?
- Formating code
- Concurrency model
- Memory model
- Abstractions 
- Modules
- Testing 
- Deployment
- Built in stuff


* Why another language 

* The problem

- Need for some serious system programming
- Pretty low level stuff (performance also a problem), so C++ was used
- Huge C++ systems have been developed (at Google)
- C++0x (today C++11) has been presented at Google
- Lot of stuff added, nothing removed
- Far from simple :-(
- Concurrency was a pain in the ass
- Maintaining a large code base was also a pain in the ass


* The solution

- A language that could do serious system programming
- That has easy access to low level stuff 
- Where performance is not a problem
- If the system grows it can scale (yeah, it is a monolith :P)
- Minimal set of features to enable great software
- Concurrency at your fingertips
- No more formating code wars :-)
- KISS :-)


For more info see [[http://commandcenter.blogspot.ca/2012/06/less-is-exponentially-more.html][Less is exponentially more]]

* Designed by

- Rob Pike (Plan9, Limbo, UTF-8, Sam, Acme)
- Ken Thompson (B, C, Unix, Plan9, UTF-8, ed)
- Robert Griesemer

.image images/Plan9-1995-729x600.gif 350 _

* Mascot

- Glenda -> Gopher

.image images/plan9go.jpg

* Syntax

- Start with C
- Improves declaration
- Left-to-Right over [[http://c-faq.com/decl/spiral.anderson.html][Clockwise/Spiral]]
  // C syntax declaration
  int *p;
  int (*fp)(int (*)(int, int), int)

  // Go syntax declaration
  var p *int    // OMG
  var fp func(func (int, int) int, int) int
- Closures declaration and invocation
  sum := func(a, b int) int { return a+b } (3, 4)

* Syntax

- Reverse array indexing
  // C array syntax
  int a[10];

  // Go array syntax
  var a [10]int

- Array declaration and initialization
  var hi []int("hi")

* Syntax

- Removed all sources misinterpretations
  // C
  if (NULL == *a) doSomethingWithNull();
  doSomethingWithA(a);

  // Go
  if NULL == *a {
          doSomethingWithNull();
  }

  doSomethingWithA(a);

- Force readability
- Facilitates lexical analyzer
- Only 25 keywords

* Freedom of syntax is bad

  char*_ = "'""/*";
  #include <stdio.h>
  #define m 21
  #define o(l, k) for(l=0; l<k; l++)
  #define n(k) o(T, k)

              int E,L,O,R,G[42][m],h[2][42][m],g[3][8],c
              [42][42][2],f[42]; char d[42]; void v( int
              b,int a,int j){ printf("\33[%d;%df\33[4%d"
              "m  ",a,b,j); } void u(){ int T,e; n(42)o(
              e,m)if(h[0][T][e]-h[1][T][e]){ v(e+4+e,T+2
              ,h[0][T][e]+1?h[0][T][e]:0); h[1][T][e]=h[
              0][T][e]; } fflush(stdout); } void q(int l
                            ,int k,int p){
                            int T,e,a; L=0
                            ; O=1; while(O
                            ){ n(4&&L){ e=
                            k+c[l] [T][0];
                            h[0][L-1+c[l][
                            T][1]][p?0-e:1

* Syntax

- Benefits of clean syntax.

Code example for remove the evil variable from the code below:

.code censorship.go /HelloWorldService/,/}/

* Syntax

- Easily parse the code using go/parser, go/token and go/ast

.code censorship.go /import/,/\)/

* Syntax

.code censorship.go /Create the AST by parsing src/,/\.\.\./ 

* Syntax

- Re-create the comments with the variables left over.
- Done!

.play censorship.go /Use the comment/,/\}\n/

* Concurrency model


* No more callback hell

Thanks to Channels and Goroutines all that you write is synchronous code.

It is like writing multi-threaded synchronous code, but without losing your sanity and personal life :-)
(it is hard to have a personal life when everything you do is debug non-deterministic code)


* Memory model

* Objects

* Abstractions

* Modules

* Error handling

* Testing

* Deployment

* Compiler Compiler


